---
title: "Single-celled bottlenecks, germlines and the evolution of complex multi-cellularity"
output:
  github_document:
    toc: true
    toc_depth: 2
  pdf_document:
    toc: yes
  html_notebook:
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float: yes
  html_document:
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float: yes
---

This document follows the same structure as 'germline_bayesian_analyses.Rmd', but uses MCMCglmm package rather than BRMS as brms was slow to run and difficult to get to converge.


# Pre-amble
```{r setup}
knitr::opts_chunk$set(message=F) # set multiple global options here
```

## load packages
```{r packages}
library(ape)
library(tidyverse)
library(MCMCglmm)
library(parallel)
library(coda)
library(ggthemes)
```

## read in data 
```{r data_input}
df<- read_csv('data/germline_data_1.2.csv', col_types = list( #import data with defining column types
  cell_types = col_integer(),
  cell_number = col_integer(),
  clonal = col_factor(),
  SexualReproductionObserved_Species = col_factor(),
  AsexualGameticObserved_Species = col_factor(),
  FissionOrBuddingObserved_Species = col_factor(),
  SexualReproductionObserved_Genus = col_factor(),
  AsexualGameticObserved_Genus = col_factor(),
  FissionOrBuddingObserved_Genus = col_factor(),
  fragmentation_or_budding = col_factor(),
  germline_timing = col_factor()
))

#create a genus column
df<- df %>% 
  separate(species, into = c('genus', 'species_name'), remove = F) 
glimpse(df)

df$cell_number<- as.integer(as.numeric(df$cell_number))
```

## data tidying
```{r germline_timing_tidying}
early = c('1','1,2','2')

df$germline_timing_simple<- ifelse(df$germline_timing %in% early, 'early', df$germline_timing)  # early germline segregation
df$germline_timing_simple<- ifelse(df$germline_timing == '0', 'no_germline', df$germline_timing_simple) # no germline/soma divide
df$germline_timing_simple<- ifelse(df$germline_timing == '3', 'adult', df$germline_timing_simple) # germline segregated in adult tissues

df<- subset(df, !is.na(cell_number))
```

## create phylogeny 
```{r phylogeny_creation}
#Get species in dataset and order by classification
species<-df %>% select(kingdom, phylum, class, order,taxon,genus,species) %>% arrange(kingdom, phylum, class, order,taxon,genus,species)

species<- species %>% mutate(across(.cols = everything(),~as.factor(.x))) #make factors
tree<-as.phylo(~kingdom/phylum/class/order/taxon/genus/species, data=species) #draw tree
tree<-multi2di(tree, random=T) #collapse and resolve multichotomies (randomly)
tree<-makeNodeLabel(tree, method="number", prefix="Node") #make node labels
tree<-compute.brlen(tree, method = "Grafen", power = 1) #compute branch lengths
tree<-di2multi(tree, tol=1e-25) # collapse and resolve multichotomies (again?)
tree<-chronoMPL(tree) #estimates age of nodes from distance to all tips
treeTrimmed<- drop.tip(tree, which(is.na(tree$tip.label))) #drop any tips where the label is NA (not sure this is an issue any longer)

#should we include an outgroup? 

is.binary.tree(treeTrimmed)
is.ultrametric(treeTrimmed)

pdf('figures/phylogenies.pdf')
plot(treeTrimmed, cex = 0.4)
dev.off()
```

```{r invtree}
#Create inverse for running MCMCglmm models 
inv_tree<-inverseA(treeTrimmed)$Ainv

df <- df %>%
  filter(df$species %in% dimnames(inv_tree)[[1]])
df<- as.data.frame(df)
```

# Analyses 

Conducting Bayesian analyses using MCMCglmm, first without phylogeny included, then including phylogeny. 

Each analysis uses relatively uninformative priors, 5 chains, 6,000,000 iterations, 100000 of which are discarded as warm-up, thinned by a factor of 1000.

(Currently use reproductive traits of genus rather than species)

* Phylogenetically naive:
  + Does a single-celled bottleneck correlate with increased cell number? (priors = normal dist, mean of 0, sd of 10)
  + Does a single-celled bottleneck correlate with increased cell types (per cell)? prior(normal(0, 10), "b")
  + Does germline timing correlate with increased cell number? prior = prior(normal(0, 10), "b")
  + Does germline timing correlate with increased cell types (per cell)?
  
* Phylogenetically informed:
  + Does a single-celled bottleneck correlate with increased cell number?  
  + Does a single-celled bottleneck correlate with increased cell types (per cell)?
  + Does germline timing correlate with increased cell number?
  + Does germline timing correlate with increased cell types (per cell)?

## Testing to establish the number of iterations:

Tested using a model without accounting for phylogeny (M1), from 1M to 10M iterations, testing with thinning of 100 and 1000, and burnin from 500000 to 1000000. 

```{r}
testing_args <- expand.grid(n_itts = as.integer(seq(1000000, 10000000, length = 7)), n_thin = as.integer(seq(100,1000, length = 2)), n_burn = as.integer(seq(500000, 1000000, length = 4)))

testing_args<- subset(testing_args, n_itts >= 2*n_burn)
#Setting the priors (there are others to try especially for binary data, but these usually work well for other familys)
p1=list(R = list(V = 1, nu=0.002)) #sets prior for residual variance, the defaults are used as priors for fixed effects (see MCMCglmm course notes)


P1_parallel_test <- mclapply(1:nrow(testing_args), function(i, n_itts,n_burn, n_thin){
 MCMCglmm(cell_number ~ FissionOrBuddingObserved_Species-1,
                family ="poisson",data = df,prior=p1, nitt=n_itts[i], burnin=n_burn[i], thin=n_thin[i], verbose = T,pr=T)
}, mc.set.seed=T, mc.cores = 4, n_itts = testing_args$n_itts, n_burn = testing_args$n_burn, n_thin = testing_args$n_thin)

options(scipen = 8) 
names(P1_parallel_test)<- paste('it:',testing_args$n_itts,'thin:',testing_args$n_thin,'burnin:',testing_args$n_burn, sep = '')
summary(P1_parallel_test)


autocorrelation_tests_VCV<- data.frame(sapply(P1_parallel_test, function(m) autocorr(m$VCV, lags = 10))) #conduct autocorrelation tests

autocorrelation_tests_long<- autocorrelation_tests_VCV %>% 
  mutate(info = rownames(.)) %>%
  extract(info, 
          into = c('iterations','thinning','burnin'),
          regex = "it:(.*)thin:(.*)burnin:(.*)") %>%
  rename(autocorrelation = 1) %>%
  mutate(iterations = as.numeric(iterations), burnin = as.factor(burnin))


ggplot(autocorrelation_tests_long, aes(x = iterations, y = abs(autocorrelation), colour = burnin, shape = thinning)) + geom_point() + geom_line() + theme_minimal()
```



##Without phylogeny
```{r FissionCellNumberMCMCglmm}
#Setting the priors
p1=list(R = list(V = 1, nu=0.002)) #sets prior for residual variance, the defaults are used as priors for fixed effects (see MCMCglmm course notes)

M1_parallel <- mclapply(1:6, function(i){
 MCMCglmm(cell_number ~ FissionOrBuddingObserved_Species-1, #-1 here removes the intercept equivalent to 0 in brms
                family ="poisson",data = df,prior=p1, nitt=2000000, burnin=100000, thin=1000,verbose = T,pr=T)
}, mc.cores = 4)
names(M1_parallel)<- c('chain1','chain2','chain3','chain4')

M1_Sol<- mcmc.list(lapply(M1_parallel, function(m) m$Sol))
plot(M1_Sol) 
gelman.diag(M1_Sol,multivariate = FALSE)

M1_VCV<- mcmc.list(lapply(M1_parallel, function(m) m$VCV))
plot(M1_VCV) 
gelman.diag(M1_VCV,multivariate = FALSE)

summary(M1_parallel$chain1)
```



```{r FissionCellTypeMCMCglmm}
#Setting the priors
p1=list(R = list(V = 1, nu=0.002)) #sets prior for residual variance, the defaults are used as priors for fixed effects (see MCMCglmm course notes)

M2_parallel <- mclapply(1:4, function(i){
 MCMCglmm(cell_types ~ FissionOrBuddingObserved_Species-1 + scale(log(cell_number)), #-1 here removes the intercept equivalent to 0 in brms
                family ="poisson",data = df,prior=p1, nitt=2000000, burnin=100000, thin=1000,verbose = T,pr=T)
}, mc.cores = 4)
names(M2_parallel)<- c('chain1','chain2','chain3','chain4')

M2_Sol<- mcmc.list(lapply(M2_parallel, function(m) m$Sol))
plot(M2_Sol) 
gelman.diag(M2_Sol,multivariate = FALSE)

M2_VCV<- mcmc.list(lapply(M2_parallel, function(m) m$VCV))
plot(M2_VCV) 
gelman.diag(M2_VCV,multivariate = FALSE)

summary(M2_parallel$chain1)
```

##With phylogeny




```{r FissionCellNumberMCMCglmmPhylo}
#Setting the priors (there are others to try especially for binary data, but these usually work well for other familys)
p2=list(R = list(V = 1, nu=0.002), 
        G = list(G1=list(V=1, nu=0.002)))#prior for random variances - there is G1 because only 1 random effect. If there were 2 it would be G = list(G1=list(V=1, nu=0.002),G2=list(V=1, nu=0.002))


P1_parallel <- mclapply(1:4, function(i){
 MCMCglmm(cell_number ~FissionOrBuddingObserved_Species-1, #-1 here removes the intercept equivalent to 0 in brms
                random = ~species, ginverse=list(species=inv_tree), # phylogeny modelled by linking species to inverse distance matrix created from phylogeny
                family ="poisson",data = df,prior=p2, nitt=2000000, burnin=100000, thin=1000,verbose = T,pr=T)
}, mc.cores = 4)
names(P1_parallel)<- c('chain1','chain2','chain3','chain4')


P1_Sol<- mcmc.list(lapply(P1_parallel, function(m) m$Sol))
plot(P1_Sol) 
gelman.diag(P1_Sol,multivariate = FALSE)

P1_VCV<- mcmc.list(lapply(P1_parallel, function(m) m$VCV))
plot(P1_VCV) 
gelman.diag(P1_VCV,multivariate = FALSE)
chain1<- P1_parallel$chain1
summary(P1_parallel$chain1)
```

```{r FissionCellTypeMCMCglmmPhylo}
P2_parallel <- mclapply(1:4, function(i){
MCMCglmm(cell_types ~ FissionOrBuddingObserved_Species-1 + scale(log(cell_number)), #-1 here removes the intercept equivalent to 0 in brms
                random = ~species, ginverse=list(species=inv_tree), # phylogeny modelled by linking species to inverse distance matrix created from phylogeny
                family ="poisson",data = df,prior=p2, nitt=2000000, burnin=100000, thin=1000,verbose = T,pr=T)
}, mc.cores = 4)

names(P2_parallel)<- c('chain1','chain2','chain3','chain4')

P2_Sol<- mcmc.list(lapply(P2_parallel, function(m) m$Sol))
plot(P2_Sol) 
gelman.diag(P2_Sol,multivariate = FALSE)

P2_VCV<- mcmc.list(lapply(P2_parallel, function(m) m$VCV))
plot(P2_VCV) 
gelman.diag(P2_VCV,multivariate = FALSE)
chain1<- P2_parallel$chain1

autocorr.diag(chain1$VCV)
posterior.mode(chain1$VCV)

posterior.mode(chain1$Sol)
HPDinterval(chain1$Sol)

print(summary.MCMCglmm(P2_parallel$chain1))

```

