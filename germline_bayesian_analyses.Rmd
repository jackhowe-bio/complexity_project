---
title: "Single-celled bottlenecks, germlines and the evolution of complex multi-cellularity"
output:
  github_document:
    toc: true
    toc_depth: 2
  pdf_document:
    toc: yes
  html_notebook:
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float: yes
  html_document:
    code_folding: show
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float: yes
---



# Pre-amble
## load packages
```{r packages}
library(ape)
library(ggplot2)
library(tidyverse)
library(knitr)
library(brms) #https://rdrr.io/cran/brms/f/vignettes/brms_phylogenetics.Rmd
library(tidybayes)
library(rotl) #see https://cran.r-project.org/web/packages/rotl/vignettes/rotl.html
library(phytools)
library(coda)
library(MCMCglmm)

#knitr::purl('germline_bayesian_analyses.Rmd','germline_bayesian_analyses.R') #read this rmd to an .R file
```

## read in data
```{r data_input}
df<- read.csv('data/germline_data_1.2.csv')
#create a genus column
df<- df %>% 
  separate(species, into = c('genus', 'species'), remove = F) 
glimpse(df)

df$cell_number<- as.integer(as.numeric(df$cell_number))
```

## create phylogeny files
```{r phylogeny_creation, message=F, results='hide'}
ResolvedNames <- tnrs_match_names(df$species, context_name = 'All life') #search for similar names in the 'open tree of life' project (ROTL)cc
ResolvedNames$IsInTree <- is_in_tree(ResolvedNames$ott_id) #T/F, did the above find a match that can be put in the phylogeny? 
ResolvedNamesInTree<- subset(ResolvedNames, IsInTree==T) #subset to only those where present in the phylogeny

AllTree<- tol_induced_subtree(ResolvedNamesInTree$ott_id, label_format = 'id') #draw the phylogeny with ids
AllTreeNames<- tol_induced_subtree(ResolvedNamesInTree$ott_id, label_format = 'name') #draw the phylogeny with names

# tree with resolved polytomies:
ResolvedPolytomiesTree<- multi2di(AllTree, random=T)
ResolvedPolytomiesTreeNames<- multi2di(AllTreeNames, random=T)

plot(ResolvedPolytomiesTreeNames)

# write to files
write.tree(ResolvedPolytomiesTree, file='data/phylogeny_all.txt') #phylogeny
write.tree(ResolvedPolytomiesTree, file='data/phylogeny_all_res_polytomy.txt') #phylogeny with resolved polytomies
write.csv(ResolvedNames, 'data/phylogeny_species_names.csv') #list of names
write.csv(ResolvedNamesInTree, 'data/phylogeny_species_names_in_tree.csv') #list of names that are present in the tree
```

#CKC edit: Can also produce a tree using taxonomic classifications - here's an example
```{r}
#Get species in dataset and order by calssifications
species<-df %>% select(kingdom, phylum, class, order,family,genus,species.updated.rotl) %>% arrange(kingdom, phylum, class, order,family,genus,species.updated.rotl)

#Add outgroup
out<-data.frame(kingdom = 'Plantae', phylum = 'Chlorophyta', class = 'Ulvophyceae', order="Ulvales",family="Kornmanniaceae",genus="Pseudendoclonium",species.updated.rotl="Pseudendoclonium basiliense")
species<-rbind(species,out)
species<- species %>% mutate(across(,~as.factor(.x)))

tree<-as.phylo(~kingdom/phylum/class/order/family/genus/species.updated.rotl, data=species)
tree<-multi2di(tree, random=T)
tree<-makeNodeLabel(tree, method="number", prefix="Node")
#tree<-root(tree, outgroup="Pseudendoclonium basiliense", resolve.root=T)
tree<-compute.brlen(tree, method = "Grafen", power = 1)
tree<-di2multi(tree, tol=1e-25)
tree<-chronoMPL(tree)
treeTrimmed<- drop.tip(tree, which(is.na(tree$tip.label)))

plot(treeTrimmed)
is.binary.tree(treeTrimmed)
is.ultrametric(treeTrimmed)

#need to make tip labels match to be able to compare...
treeTrimmed$tip.label
ResolvedPolytomiesTreeNames$tip.label <- gsub("_"," ",ResolvedPolytomiesTreeNames$tip.label)
ResolvedPolytomiesTreeNames$tip.label <- str_remove(ResolvedPolytomiesTreeNames$tip.label, " \\(.*\\)$")

#Can then compare the trees using a cophylogeny plot
Cophy<-cophylo(ResolvedPolytomiesTreeNames,treeTrimmed,rotate=T)
pdf('figures/phylogenies.pdf')
plot.phylo(ResolvedPolytomiesTree, cex = 0.5)
plot(treeTrimmed, cex = 0.4)
dev.off()

pdf('figures/cophylogeny.pdf')
plot(Cophy,link.type="curved",link.lwd=3,link.lty="solid",
     link.col=make.transparent("blue",0.25),fsize=0.2)
dev.off()


```

Preparing the phylogeny data
```{r}
#read in phylogeny
phylo<- tree
#subset df above with just those that are in the tree (note some missing)
names_in_tree<- read.csv('data/phylogeny_species_names_in_tree.csv')
names_in_tree$ott_id<- paste('ott',names_in_tree$ott_id, sep = '')
#phylo$tip.label %in% names_in_tree$ott_id #to check whether they're all present
names_in_tree<- subset(names_in_tree, names_in_tree$ott_id %in% phylo$tip.label)
#which species in the table are in the tree
df$species.updated.rotl<- tolower(df$species.updated.rotl)
df<- subset(df, tolower(df$species.updated.rotl) %in% tolower(names_in_tree$search_string))
#give them the ids in a column sot hat brms can match it up
df$species_id<- names_in_tree$ott_id
```
Covariance matrix produced using branch lengths of 1 (as in Fisher et al)
```{r}
# set branch lengths to 1 for covariance matrix
phylo_1b <- compute.brlen(phylo, 1)
#create covariance matrix
CovarMatrix <- ape::vcv.phylo(phylo_1b)


cbind(df$species.updated.rotl, gsub("_", " ", tree$tip.label))
df$species.updated.rotl %in% gsub("_", " ", tree$tip.label)

# trying alternative
dfs <- df %>%
  dplyr::filter(df$species.updated.rotl %in% gsub("_", " ", tree$tip.label)) %>%
  janitor::clean_names()

scaled_tree <- tree
scaled_tree$edge.length <- scaled_tree$edge.length / (max(tree$edge.length))

tree_vcv_cov <- ape::vcv(tree, corr = FALSE) #covariance matrix
tree_vcv_scaled <- ape::vcv(scaled_tree, corr = FALSE) #scaled covariance matrix
tree_vcv_cor<- ape::vcv(tree, corr = T) #correlation matrix


```

```{r plot_phylogeny}
#plot phylogeny to check
plot(scaled_tree, no.margin = TRUE, cex = 0.5, label.offset = 0.5)
```

## data tidying 

Change the fission or budding observed column to 'yes' vs 'no' to make sure it is not doing some weird numeric thing
```{r}
df$FissionOrBuddingObserved_Genus_nominal <- ifelse(df$FissionOrBuddingObserved_Genus == 1, 'yes','no')
```

```{r germline_timing_tidying}
early = c('1','1,2','2')

df$germline_timing_simple<- ifelse(df$germline_timing %in% early, 'early', df$germline_timing) 
df$germline_timing_simple<- ifelse(df$germline_timing == '0', 'no_germline', df$germline_timing_simple) 
df$germline_timing_simple<- ifelse(df$germline_timing == '3', 'adult', df$germline_timing_simple) 
```

# Analyses 

Conducting Bayesian analyses using BRMS, first without phylogeny included, then including phylogeny. Each analysis contains the code that defines the model, and briefly analyses them-- producing summary stats and figs.

See below for analyses of:

Each analysis uses vague priors, 5 chains, 6,000,000 iterations, 100000 of which are discarded as warm-up, thinned by a factor of 1000.

(Currently use reproductive traits of genus rather than species)

* Phylogenetically naive:
  + Does a single-celled bottleneck correlate with increased cell number? (priors = normal dist, mean of 0, sd of 10)
  + Does a single-celled bottleneck correlate with increased cell types (per cell)? prior(normal(0, 10), "b")
  + Does germline timing correlate with increased cell number? prior = prior(normal(0, 10), "b")
  + Does germline timing correlate with increased cell types (per cell)?
  
* Phylogenetically informed:
  + Does a single-celled bottleneck correlate with increased cell number?  
  + Does a single-celled bottleneck correlate with increased cell types (per cell)?
  + Does germline timing correlate with increased cell number?
  + Does germline timing correlate with increased cell types (per cell)?

To do: do any of these things need scaled?


## Phylogenetically naive
### Does a single-celled bottleneck correlate with increased cell number?
Using simple normally-distributed, relatively non-informative prior

One possibility is that the 0s and 1s are treated as numeric, when they should be categorical, so change to yes/no.

```{r FissionCellNumber}
#fit the model 
fit_fission_cell_num<-
  brm(data = df,
      family=gaussian(), # family of model
      formula = log(cell_number) ~ 0 + FissionOrBuddingObserved_Genus_nominal,  #formula, the 0 means that there are estimates for both clonal and non-clonal, rather than relative to each other
      iter = 6000000, warmup = 100000, chains = 5,thin = 1000, cores = 5, #chain settings
      prior = prior(normal(0, 10), "b"), #defining the priors- for things in 'class b' set this prior. (can also use get_priors() and set_priors() fucncitons) 
      file = 'fits/fit_FissionCellNumber' ) 

#### Assessing model:  
plot(fit_fission_cell_num) #check that chains converged
pp_check(fit_fission_cell_num) #check the predictions
summary(fit_fission_cell_num) #summary of model 
posterior_summary(fit_fission_cell_num, robust = T)
plot(conditional_effects(fit_fission_cell_num, points = TRUE, ask = F)) 

hyp = hypothesis(fit_fission_cell_num,  "FissionOrBuddingObserved_Genus_nominalno > FissionOrBuddingObserved_Genus_nominalyes") #test hypothesis that there is no difference based on coefficients
hyp
plot(hyp)
```

#CKC edit: can also check convergence using gelman's diagnostic and examining autocorrelation between samples
```{r}
fit_fission_cell_num$Rhat
gelman.diag(fit_fission_cell_num)
autocor(fit_fission_cell_num)
```


### Does a single-celled bottleneck correlate with increased cell types (per cell)?
```{r FissionCellType}
#fit the model 
fit_fission_cell_type<-
  brm(data = df,
      family=poisson(),
      formula = cell_types ~ 0 + FissionOrBuddingObserved_Genus_nominal + scale(log(cell_number)),  #formula, the 0 means that there are estimates for both clonal and non-clonal, rather than relative to each other
      iter = 6000000, warmup = 100000, chains = 5,thin = 1000, cores = 5, #chain settings
      prior = prior(normal(0, 10), "b"), #defining the priors- for things in 'class b' set this prior. (can also use get_priors() and set_priors() fucncitons) 
      file = 'fits/fit_FissionCellType' ) 

plot(fit_fission_cell_type) #check that chains converged
pp_check(fit_fission_cell_type) #check the predictions
summary(fit_fission_cell_type) #summary of model 
posterior_summary(fit_fission_cell_type, robust = T)
plot(conditional_effects(fit_fission_cell_type, points = TRUE, ask = F)) 

hyp = hypothesis(fit_fission_cell_type,  "FissionOrBuddingObserved_Genus_nominalno > FissionOrBuddingObserved_Genus_nominalyes") #test hypothesis that there is no difference based on coefficients
hyp
plot(hyp)
```
### Does germline timing correlate with increased cell number?
```{r GermCellNumber}
prior <- get_prior(log(cell_number) ~ 0 + germline_timing_simple, family=gaussian(), data = df) #what priors do we need to define?

#fit the model 
fit_germline_cell_num<-
  brm(data = df,
      family=gaussian(), # family of model
      formula = log(cell_number) ~ 0 + germline_timing_simple,  #formula, the 0 means that there are estimates for both clonal and non-clonal, rather than relative to each other
      iter = 6000000, warmup = 100000, chains = 5,thin = 1000, cores = 5, #chain settings
      prior = prior(normal(0, 10), "b"), #defining the priors- for things in 'class b' set this prior. (can also use get_priors() and set_priors() fucncitons) 
      file = 'fits/fit_GermCellNum' ) 

plot(fit_germline_cell_num) #check that chains converged
pp_check(fit_germline_cell_num) #check the predictions
plot(conditional_effects(fit_germline_cell_num), points = TRUE) 

summary(fit_germline_cell_num)
pairs(fit_germline_cell_num)
posterior_summary(fit_germline_cell_num, robust = T) #what are the medians for coefficients? if F, then returns means
```

### Does germline timing correlate with increased cell types (per cell)?
```{r GermCellType}
fit_type<-
  brm(data = df,
      family=poisson(),
      formula = cell_types ~ 0 + germline_timing_simple + scale(log(cell_number)),
      iter = 1000000, warmup = 100000, chains = 5, thin = 10000, cores = 5,
      prior = prior(normal(0, 10), "b"), file = 'fits/fit_GermCellType')

plot(fit_type) #check that chains converged
pp_check(fit_type) #check the predictions

summary(fit_type) #summary of model 
posterior_summary(fit_type, robust = T)
plot(conditional_effects(fit_type), points = TRUE, ask = F) 
```

## Phylogenetically informed:

### Does a single-celled bottleneck correlate with increased cell number?  

```{r FissionCellNumber_phy}
fit_cellnumber_fission_phy<-
  brm(data = df,
      family=poisson(), # family of model
      formula = cell_number ~ FissionOrBuddingObserved_Genus_nominal + (1|gr(species.updated.rotl, cov = tree_vcv_cor)),
      prior = c(
        prior(normal(0, 5), "b"),
        prior(normal(0, 20), "Intercept"),
        prior(student_t(3, 0, 20), "sd")), 
      iter = 500000, warmup = 50000,thin = 100, threads = threading(10), cores = 2, chains = 4,
      file_refit = "always", 
      file = 'fits/fit_phy_FissionCellNumber_long',
      backend = "cmdstanr", 
      data2 = list(tree_vcv_cor = tree_vcv_cor))

plot(fit_cellnumber_fission_phy) #check that chains converged
pairs(fit_cellnumber_fission_phy)
pp_check(fit_cellnumber_fission_phy) #check the predictions
summary(fit_cellnumber_fission_phy) #summary of model 
posterior_summary(fit_cellnumber_fission_phy, robust = T)
plot(conditional_effects(fit_cellnumber_fission_phy, points = TRUE, ask = F)) 

hyp = hypothesis(fit_cellnumber_fission_phy,  "FissionOrBuddingObserved_Genus_nominalno > FissionOrBuddingObserved_Genus_nominalyes") #test hypothesis that there is no difference based on coefficients
hyp
plot(hyp)
```

```{r trying with mcmcglmm}
# ResolvedPolytomiesTree$node.label<- NULL
# inv.phylo<-inverseA(ResolvedPolytomiesTree,scale=TRUE)
# prior<-list(G=list(G1=list(V=1,nu=0.02)),R=list(V=1,nu=0.02))
# 
# df<- df[,-14]
# 
# model_simple<-
#   MCMCglmm(cell_number~FissionOrBuddingObserved_Genus_nominal,
#            random=~ResolvedPolytomiesTree,
#            family="poisson",
#            prior=prior,
#            data=df,
#            nitt=5000,
#            burnin=1000,
#            thin=500)

```

### Does a single-celled bottleneck correlate with increased cell types (per cell)?
```{r FissionCellType_phy}
# #fit the model 
# phylo_fit_fission_cell_type<-
#   brm(data = df,
#       family=poisson(),
#       formula = cell_types ~ 0 + FissionOrBuddingObserved_Genus_nominal + scale(log(cell_number)) + (1|gr(species_id, cov = CovarMatrix)),  #formula, the 0 means that there are estimates for both clonal and non-clonal, rather than relative to each other
#       prior = c(
#         prior(normal(0, 10), "b"),
#         prior(normal(0, 50), "Intercept"),
#         prior(student_t(3, 0, 20), "sd")),  
#       iter = 100000, warmup = 10000, chains = 2, thin = 100, cores = 2, threads = threading(2), 
#       file_refit = "on_change",
#       backend = "cmdstanr", 
#       data2 = list(CovarMatrix = CovarMatrix),
#       file = 'fits/fit_phy_FissionCellType') 
# 
# plot(phylo_fit_fission_cell_type) #check that chains converged
# pp_check(phylo_fit_fission_cell_type) #check the predictions
# summary(phylo_fit_fission_cell_type) #summary of model 
# posterior_summary(phylo_fit_fission_cell_type, robust = T)
# plot(conditional_effects(phylo_fit_fission_cell_type, points = TRUE, ask = F)) 
# 
# hyp = hypothesis(phylo_fit_fission_cell_type,  "FissionOrBuddingObserved_Genus_nominalno > FissionOrBuddingObserved_Genus_nominalyes") #test hypothesis that there is no difference based on coefficients
# hyp
# plot(hyp)
```

### Does germline timing correlate with increased cell number?
```{r GermCellNum_phy}
#fit the model 
# phylofit_germline_cell_num<-
#   brm(data = df,
#       family=poisson(), # family of model
#       formula = cell_number ~ 0 + germline_timing_simple  + (1|gr(species_id, cov = CovarMatrix)),  #formula, the 0 means that there are estimates for both clonal and non-clonal, rather than relative to each other
#       data2 = list(CovarMatrix = CovarMatrix) ,
#       prior = c(
#         prior(normal(0, 10), "b"),
#         prior(normal(0, 50), "Intercept"),
#         prior(student_t(3, 0, 20), "sd")),  
#       iter = 100000, warmup = 10000, chains = 3, thin = 100, cores = 3, threads = threading(6), 
#       backend = "cmdstanr",
#       file_refit = "on_change",
#       file = 'fits/fit_phy_GermCellNum') 
# 
# plot(phylofit_germline_cell_num) #check that chains converged
# pp_check(phylofit_germline_cell_num) #check the predictions
# plot(conditional_effects(phylofit_germline_cell_num), points = TRUE) 
# 
# summary(phylofit_germline_cell_num)
# pairs(phylofit_germline_cell_num)
# posterior_summary(phylofit_germline_cell_num, robust = T) #what are the medians for coefficients? if F, then returns means
# 
# hyp = hypothesis(phylofit_germline_cell_num,  c("germline_timing_simpleearly = germline_timing_simple", "germline_timing_simpleearly = germline_timing_simpleadult", "germline_timing_simpleearly = germline_timing_simpleno_germline")) #test hypothesis that there is no difference based on coefficients
# hyp
# plot(hyp)
```

### Does germline timing correlate with increased cell types (per cell)?

```{r GermCellType_phy}

# fit_type_phy<-
#   brm(data = df,
#       family=poisson(),
#       formula = cell_types ~ 0 + germline_timing_simple + scale(log(cell_number)) + (1|gr(species_id, cov = CovarMatrix)),
#             prior = c(
#         prior(normal(0, 10), "b"),
#         prior(normal(0, 50), "Intercept"),
#         prior(student_t(3, 0, 20), "sd")),  iter = 100000, warmup = 10000, chains = 3, thin = 100, cores = 3, threads = threading(6), 
#       file_refit = "on_change",
#       backend = "cmdstanr", 
#       file = 'fits/fit_phy_GermCellType', # same simple prior
#       data2 = list(CovarMatrix = CovarMatrix))
# 
# plot(fit_type_phy) #check that chains converged
# pp_check(fit_type_phy) #check the predictions
# summary(fit_type_phy) #summary of model 
# posterior_summary(fit_type_phy, robust = T)
# plot(conditional_effects(fit_type_phy, points = TRUE, ask = F)) 
# 
# hyp = hypothesis(fit_type_phy,  c("germline_timing_simpleearly = germline_timing_simple", "germline_timing_simpleearly = germline_timing_simpleadult", "germline_timing_simpleearly = germline_timing_simpleno_germline"))
# hyp
# plot(hyp)


fit_type_phy<-
  brm(data = df,
      family=poisson(),
      formula = cell_types ~ 0 + germline_timing_simple + scale(log(cell_number)) + (1|gr(species_id, cov = CovarMatrix)),
      iter = 6000000, warmup = 100000, chains = 5, thin = 1000, cores = 5,
      prior = prior(normal(0, 10), "b"), file = 'fits/fit_phy_GermCellType', # same simple prior
      data2 = list(CovarMatrix = CovarMatrix))

plot(fit_type_phy) #check that chains converged
pp_check(fit_type_phy) #check the predictions
summary(fit_type_phy) #summary of model 
posterior_summary(fit_type_phy, robust = T)
plot(conditional_effects(fit_type_phy, points = TRUE, ask = F)) 

hyp = hypothesis(fit_type_phy,  c("germline_timing_simpleearly = germline_timing_simple", "germline_timing_simpleearly = germline_timing_simpleadult", "germline_timing_simpleearly = germline_timing_simpleno_germline"))
hyp
plot(hyp)
```


#CKC edit: MCMCglmm models 
##Without phylogeny
```{r FissionCellNumberMCMCglmm}
#Setting the priors
p1=list(R = list(V = 1, nu=0.002)) #sets prior for residual variance, the defaults are used as priors for fixed effects (see MCMCglmm course notes)

#fit the model (run 3 times to assess convergence - can be parallelised using mclapply())
M1.1<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1, #-1 here removes the intercept equivalent to 0 in brms
                family ="poisson",data = df,prior=p1, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)

M1.2<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1,family ="poisson",data = df,prior=p1, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)
M1.3<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1, family ="poisson",data = df,prior=p1, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)


#### Assessing model: 
#plot the fixed effects
M1.1Sol<-mcmc.list(M1.1$Sol,M1.2$Sol,M1.3$Sol)
plot(M1.1Sol) 

#plot the random effects
M1.1VCV<-mcmc.list(M1.1$VCV,M1.2$VCV,M1.3$VCV)
plot(M1.1VCV) 

gelman.diag(M1.1Sol,multivariate = FALSE)
gelman.diag(M1.1VCV,multivariate = FALSE)
```

##With phylogeny
```{r FissionCellNumberMCMCglmmPhylo}
#Create inverse for running MCMCglmm models 
inv_tree<-inverseA(tree)$Ainv

#Setting the priors (there are others to try especially for binary data, but these usually work well for other familys)
p2=list(R = list(V = 1, nu=0.002), 
        G = list(G1=list(V=1, nu=0.002)))#prior for random variances - there is G1 because only 1 random effect. If there were 2 it would be G = list(G1=list(V=1, nu=0.002),G2=list(V=1, nu=0.002))

#fit the model (run 3 times to assess convergence - can be parallelised using mclapply())
P1.1<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1, #-1 here removes the intercept equivalent to 0 in brms
                random = ~species, ginverse=list(species=inv_tree), # phylogeny modelled by linking species to inverse distance matrix created from phylogeny
                family ="poisson",data = df,prior=p2, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)

P1.2<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1,random = ~species, ginverse=list(species=inv_tree),family ="poisson",data = df,prior=p2, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)
P1.3<- MCMCglmm(cell_number ~FissionOrBuddingObserved_Genus_nominal-1, random = ~species, ginverse=list(species=inv_tree),family ="poisson",data = df,prior=p2, nitt=6000000, burnin=100000, thin=1000,verbose = FALSE,pr=T)


#### Assessing model: 
#plot the fixed effects
P1.1Sol<-mcmc.list(P1.1$Sol,P1.2$Sol,P1.3$Sol)
plot(P1.1Sol) 

#plot the random effects
P1.1VCV<-mcmc.list(P1.1$VCV,P1.2$VCV,P1.3$VCV)
plot(P1.1VCV) 

gelman.diag(P1.1Sol,multivariate = FALSE)
gelman.diag(P1.1VCV,multivariate = FALSE)
```

#MCMCglmm multi-response model to estimate phylogenetic correlations

```{r multiresponseMCMCglmmPhylo}
#Bivariate model
pM2.1 =list(B=list(mu=c(0,0), V=diag(c(1,1+pi^2/3))),
          R = list(V = diag(2),nu=1, fix=1), #Residual variance not identifiable for binary variables
          G = list(G1=list(V = diag(2), nu = 1, alpha.mu = c(0,0), alpha.V = diag(c(1000,1000)))))#parameter expanded priors, usually good for binary data

#Here both responses need to 0 and 1s or yes and nos
M2.1<- MCMCglmm(cbind(FissionOrBuddingObserved_Genus_nominal,germline_timing_simple) ~ trait-1, 
                random = ~us(trait):species, #2x2 phylogenetic covariance matrix 
                rcov = ~us(trait):units, #2x2 residual covariance matrix 
                ginverse=list(species=inv_tree),family = c("categorical","categorical"), data = df,prior=pM2.1, nitt=6000000, burnin=100000, thin=1000,verbose = F)
```
